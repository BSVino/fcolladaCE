\hypertarget{namespacefm}{
\section{fm Namespace Reference}
\label{namespacefm}\index{fm@{fm}}
}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classfm_1_1DefaultInitializationAllocate}{DefaultInitializationAllocate}
\item 
class \hyperlink{classfm_1_1DefaultInitializationRelease}{DefaultInitializationRelease}
\item 
class \hyperlink{classfm_1_1vector}{vector}
\item 
class \hyperlink{classfm_1_1pvector}{pvector}
\item 
class \hyperlink{classfm_1_1comparator}{comparator}
\item 
class \hyperlink{classfm_1_1icomparator}{icomparator}
\item 
class \hyperlink{classfm_1_1pcomparator}{pcomparator}
\item 
class \hyperlink{classfm_1_1pair}{pair}
\item 
class \hyperlink{classfm_1_1tree}{tree}
\item 
class \hyperlink{classfm_1_1set}{set}
\item 
class \hyperlink{classfm_1_1map}{map}
\item 
class \hyperlink{classfm_1_1stringT}{stringT}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void $\ast$($\ast$ \hyperlink{namespacefm_a97324e93febfca76d5ed574a89c0197d}{AllocateFunc} )(size\_\-t size)
\item 
typedef void($\ast$ \hyperlink{namespacefm_a9b240a6540d27367231e6fd6d93ec35c}{FreeFunc} )(void $\ast$buffer)
\item 
typedef \hyperlink{classfm_1_1stringT}{stringT}$<$ char $>$ \hyperlink{namespacefm_ac112eb8f56d62ea729aa6d1edd7233a4}{string}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespacefm_a08282cf09faa7bc67137a62ba56b329c}{SetAllocationFunctions} (\hyperlink{namespacefm_a97324e93febfca76d5ed574a89c0197d}{AllocateFunc} a, \hyperlink{namespacefm_a9b240a6540d27367231e6fd6d93ec35c}{FreeFunc} f)
\item 
void $\ast$ \hyperlink{namespacefm_a554b71c8980290cf12761186ad36c08a}{Allocate} (size\_\-t byteCount)
\item 
void \hyperlink{namespacefm_ac85d46ada49418f6c4b758bc96f24cbf}{Release} (void $\ast$buffer)
\item 
{\footnotesize template$<$class Type1 $>$ }\\void \hyperlink{namespacefm_abb21e5b6aed1f1af6dd80d0b319c2a93}{Construct} (Type1 $\ast$o)
\item 
{\footnotesize template$<$class Type1 , class Type2 $>$ }\\void \hyperlink{namespacefm_a2f7f76266bc5e32b58c3258289492367}{Construct} (Type1 $\ast$o, const Type2 \&value)
\item 
{\footnotesize template$<$class T $>$ }\\void \hyperlink{namespacefm_a969a63d5081b8d2dce35a096af1fb7d2}{swap} (T \&a, T \&b)
\item 
{\footnotesize template$<$class CharT $>$ }\\\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \hyperlink{namespacefm_ae1c519de7f44b9d074f17e65c5f56ee8}{operator+} (const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \hyperlink{namespacefm_a6dbe5aa45a2924ca3c57f5655b098338}{operator+} (const CharT $\ast$A, const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \hyperlink{namespacefm_a9e42af087b963766af56c8519e2cea66}{operator+} (const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const CharT $\ast$B)
\item 
{\footnotesize template$<$class CharT $>$ }\\\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \& \hyperlink{namespacefm_ae2a51530ac520855c418d672364f8a8c}{operator+=} (\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \& \hyperlink{namespacefm_a84c48305a88f6e91eb9355b3d6d4402b}{operator+=} (\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const CharT $\ast$B)
\item 
{\footnotesize template$<$class CharT $>$ }\\\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \& \hyperlink{namespacefm_a75a83dfab92ba8527822533f5e85d788}{operator+=} (\hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const CharT \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\bool \hyperlink{namespacefm_a242945dabb23c11e3d1ba4028f46237f}{operator$<$} (const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\bool \hyperlink{namespacefm_ab5395f6c2bb26023b1f5323cbb6322ab}{operator==} (const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\bool \hyperlink{namespacefm_aae637edcca728debaa3e9e3a4ce913b5}{operator!=} (const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&B)
\item 
{\footnotesize template$<$class CharT $>$ }\\bool \hyperlink{namespacefm_a289fcca02fd1babcb8bdf4c25b20570c}{operator!=} (const \hyperlink{classfm_1_1stringT}{stringT}$<$ CharT $>$ \&A, const CharT $\ast$B)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace that contains the overwritten STL classes. 

\subsection{Typedef Documentation}
\hypertarget{namespacefm_a97324e93febfca76d5ed574a89c0197d}{
\index{fm@{fm}!AllocateFunc@{AllocateFunc}}
\index{AllocateFunc@{AllocateFunc}!fm@{fm}}
\subsubsection[{AllocateFunc}]{\setlength{\rightskip}{0pt plus 5cm}typedef void$\ast$($\ast$ {\bf fm::AllocateFunc})(size\_\-t size)}}
\label{namespacefm_a97324e93febfca76d5ed574a89c0197d}
An allocation function type. 
\begin{DoxyParams}{Parameters}
\item[{\em size}]The size, in bytes, to allocate. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
The allocated buffer or NULL if not enough memory is available. 
\end{DoxyReturn}
\hypertarget{namespacefm_a9b240a6540d27367231e6fd6d93ec35c}{
\index{fm@{fm}!FreeFunc@{FreeFunc}}
\index{FreeFunc@{FreeFunc}!fm@{fm}}
\subsubsection[{FreeFunc}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$ {\bf fm::FreeFunc})(void $\ast$buffer)}}
\label{namespacefm_a9b240a6540d27367231e6fd6d93ec35c}
A deallocation function type. 
\begin{DoxyParams}{Parameters}
\item[{\em buffer}]The memory buffer to deallocate. \end{DoxyParams}
\hypertarget{namespacefm_ac112eb8f56d62ea729aa6d1edd7233a4}{
\index{fm@{fm}!string@{string}}
\index{string@{string}!fm@{fm}}
\subsubsection[{string}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf stringT}$<$char$>$ {\bf fm::string}}}
\label{namespacefm_ac112eb8f56d62ea729aa6d1edd7233a4}
A string of UTF8 characters. 

\subsection{Function Documentation}
\hypertarget{namespacefm_a554b71c8980290cf12761186ad36c08a}{
\index{fm@{fm}!Allocate@{Allocate}}
\index{Allocate@{Allocate}!fm@{fm}}
\subsubsection[{Allocate}]{\setlength{\rightskip}{0pt plus 5cm}FCOLLADA\_\-EXPORT void $\ast$ fm::Allocate (
\begin{DoxyParamCaption}
\item[{size\_\-t}]{ byteCount}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a554b71c8980290cf12761186ad36c08a}
Allocates a requested amount of memory. 
\begin{DoxyParams}{Parameters}
\item[{\em byteCount}]The amount of memory to allocate, in bytes. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the memory address. This pointer will be NULL if there is not enough memory to allocate. 
\end{DoxyReturn}
\hypertarget{namespacefm_abb21e5b6aed1f1af6dd80d0b319c2a93}{
\index{fm@{fm}!Construct@{Construct}}
\index{Construct@{Construct}!fm@{fm}}
\subsubsection[{Construct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Type1 $>$ void fm::Construct (
\begin{DoxyParamCaption}
\item[{Type1 $\ast$}]{ o}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacefm_abb21e5b6aed1f1af6dd80d0b319c2a93}
Construct the object at a given pointer. 
\begin{DoxyParams}{Parameters}
\item[{\em o}]A pointer to the object. \end{DoxyParams}
\hypertarget{namespacefm_a2f7f76266bc5e32b58c3258289492367}{
\index{fm@{fm}!Construct@{Construct}}
\index{Construct@{Construct}!fm@{fm}}
\subsubsection[{Construct}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class Type1 , class Type2 $>$ void fm::Construct (
\begin{DoxyParamCaption}
\item[{Type1 $\ast$}]{ o, }
\item[{const Type2 \&}]{ value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacefm_a2f7f76266bc5e32b58c3258289492367}
Construct the object at a given pointer. 
\begin{DoxyParams}{Parameters}
\item[{\em o}]A pointer to the object. \item[{\em value}]The value to copy. \end{DoxyParams}
\hypertarget{namespacefm_a289fcca02fd1babcb8bdf4c25b20570c}{
\index{fm@{fm}!operator!=@{operator!=}}
\index{operator!=@{operator!=}!fm@{fm}}
\subsubsection[{operator!=}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ bool fm::operator!= (
\begin{DoxyParamCaption}
\item[{const stringT$<$ CharT $>$ \&}]{ A, }
\item[{const CharT $\ast$}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a289fcca02fd1babcb8bdf4c25b20570c}
Retrieves whether a first string differs from a second string. 
\begin{DoxyParams}{Parameters}
\item[{\em A}]A first string. \item[{\em B}]A second string. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the first string differs from the second string. 
\end{DoxyReturn}
\hypertarget{namespacefm_aae637edcca728debaa3e9e3a4ce913b5}{
\index{fm@{fm}!operator!=@{operator!=}}
\index{operator!=@{operator!=}!fm@{fm}}
\subsubsection[{operator!=}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ bool fm::operator!= (
\begin{DoxyParamCaption}
\item[{const stringT$<$ CharT $>$ \&}]{ A, }
\item[{const stringT$<$ CharT $>$ \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_aae637edcca728debaa3e9e3a4ce913b5}
Retrieves whether a first string differs from a second string. 
\begin{DoxyParams}{Parameters}
\item[{\em A}]A first string. \item[{\em B}]A second string. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the first string differs from the second string. 
\end{DoxyReturn}
\hypertarget{namespacefm_a6dbe5aa45a2924ca3c57f5655b098338}{
\index{fm@{fm}!operator+@{operator+}}
\index{operator+@{operator+}!fm@{fm}}
\subsubsection[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ {\bf stringT}$<$CharT$>$ fm::operator+ (
\begin{DoxyParamCaption}
\item[{const CharT $\ast$}]{ A, }
\item[{const stringT$<$ CharT $>$ \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a6dbe5aa45a2924ca3c57f5655b098338}
See above. \hypertarget{namespacefm_a9e42af087b963766af56c8519e2cea66}{
\index{fm@{fm}!operator+@{operator+}}
\index{operator+@{operator+}!fm@{fm}}
\subsubsection[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ {\bf stringT}$<$CharT$>$ fm::operator+ (
\begin{DoxyParamCaption}
\item[{const stringT$<$ CharT $>$ \&}]{ A, }
\item[{const CharT $\ast$}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a9e42af087b963766af56c8519e2cea66}
See above. \hypertarget{namespacefm_ae1c519de7f44b9d074f17e65c5f56ee8}{
\index{fm@{fm}!operator+@{operator+}}
\index{operator+@{operator+}!fm@{fm}}
\subsubsection[{operator+}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ {\bf stringT}$<$CharT$>$ fm::operator+ (
\begin{DoxyParamCaption}
\item[{const stringT$<$ CharT $>$ \&}]{ A, }
\item[{const stringT$<$ CharT $>$ \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_ae1c519de7f44b9d074f17e65c5f56ee8}
Concatenates two strings. 
\begin{DoxyParams}{Parameters}
\item[{\em A}]A first string. \item[{\em B}]A second string. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
The concatenation of the two strings. 
\end{DoxyReturn}
\hypertarget{namespacefm_a84c48305a88f6e91eb9355b3d6d4402b}{
\index{fm@{fm}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!fm@{fm}}
\subsubsection[{operator+=}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ {\bf stringT}$<$CharT$>$\& fm::operator+= (
\begin{DoxyParamCaption}
\item[{stringT$<$ CharT $>$ \&}]{ A, }
\item[{const CharT $\ast$}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a84c48305a88f6e91eb9355b3d6d4402b}
See above. \hypertarget{namespacefm_ae2a51530ac520855c418d672364f8a8c}{
\index{fm@{fm}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!fm@{fm}}
\subsubsection[{operator+=}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ {\bf stringT}$<$CharT$>$\& fm::operator+= (
\begin{DoxyParamCaption}
\item[{stringT$<$ CharT $>$ \&}]{ A, }
\item[{const stringT$<$ CharT $>$ \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_ae2a51530ac520855c418d672364f8a8c}
See above. \hypertarget{namespacefm_a75a83dfab92ba8527822533f5e85d788}{
\index{fm@{fm}!operator+=@{operator+=}}
\index{operator+=@{operator+=}!fm@{fm}}
\subsubsection[{operator+=}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ {\bf stringT}$<$CharT$>$\& fm::operator+= (
\begin{DoxyParamCaption}
\item[{stringT$<$ CharT $>$ \&}]{ A, }
\item[{const CharT \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a75a83dfab92ba8527822533f5e85d788}
Appends a character to a string. 
\begin{DoxyParams}{Parameters}
\item[{\em A}]A string. \item[{\em B}]A character. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
The concatenation of the string with the character. 
\end{DoxyReturn}
\hypertarget{namespacefm_a242945dabb23c11e3d1ba4028f46237f}{
\index{fm@{fm}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!fm@{fm}}
\subsubsection[{operator$<$}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ bool fm::operator$<$ (
\begin{DoxyParamCaption}
\item[{const stringT$<$ CharT $>$ \&}]{ A, }
\item[{const stringT$<$ CharT $>$ \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a242945dabb23c11e3d1ba4028f46237f}
Retrieves whether a first string is lesser than a second string. This comparison is done solely on the character buffers and not the lengths. 
\begin{DoxyParams}{Parameters}
\item[{\em A}]A first string. \item[{\em B}]A second string. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the first string is lesser than the second string. 
\end{DoxyReturn}
\hypertarget{namespacefm_ab5395f6c2bb26023b1f5323cbb6322ab}{
\index{fm@{fm}!operator==@{operator==}}
\index{operator==@{operator==}!fm@{fm}}
\subsubsection[{operator==}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class CharT $>$ bool fm::operator== (
\begin{DoxyParamCaption}
\item[{const stringT$<$ CharT $>$ \&}]{ A, }
\item[{const stringT$<$ CharT $>$ \&}]{ B}
\end{DoxyParamCaption}
)}}
\label{namespacefm_ab5395f6c2bb26023b1f5323cbb6322ab}
Retrieves whether a first string is equal to a second string. 
\begin{DoxyParams}{Parameters}
\item[{\em A}]A first string. \item[{\em B}]A second string. \end{DoxyParams}
\begin{DoxyReturn}{Returns}
Whether the first string is equal to the second string. 
\end{DoxyReturn}
\hypertarget{namespacefm_ac85d46ada49418f6c4b758bc96f24cbf}{
\index{fm@{fm}!Release@{Release}}
\index{Release@{Release}!fm@{fm}}
\subsubsection[{Release}]{\setlength{\rightskip}{0pt plus 5cm}FCOLLADA\_\-EXPORT void fm::Release (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ buffer}
\end{DoxyParamCaption}
)}}
\label{namespacefm_ac85d46ada49418f6c4b758bc96f24cbf}
Releases a memory buffer. 
\begin{DoxyParams}{Parameters}
\item[{\em buffer}]The memory buffer to release. \end{DoxyParams}
\hypertarget{namespacefm_a08282cf09faa7bc67137a62ba56b329c}{
\index{fm@{fm}!SetAllocationFunctions@{SetAllocationFunctions}}
\index{SetAllocationFunctions@{SetAllocationFunctions}!fm@{fm}}
\subsubsection[{SetAllocationFunctions}]{\setlength{\rightskip}{0pt plus 5cm}FCOLLADA\_\-EXPORT void fm::SetAllocationFunctions (
\begin{DoxyParamCaption}
\item[{AllocateFunc}]{ a, }
\item[{FreeFunc}]{ f}
\end{DoxyParamCaption}
)}}
\label{namespacefm_a08282cf09faa7bc67137a62ba56b329c}
Sets the \hyperlink{namespaceFCollada}{FCollada} memory allocation / deallocation functions. 
\begin{DoxyParams}{Parameters}
\item[{\em a}]The Allocation function. Defaults to malloc. \item[{\em f}]The Deallocation function. Defaults to free. \end{DoxyParams}
\hypertarget{namespacefm_a969a63d5081b8d2dce35a096af1fb7d2}{
\index{fm@{fm}!swap@{swap}}
\index{swap@{swap}!fm@{fm}}
\subsubsection[{swap}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ void fm::swap (
\begin{DoxyParamCaption}
\item[{T \&}]{ a, }
\item[{T \&}]{ b}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}inline\mbox{]}}}}
\label{namespacefm_a969a63d5081b8d2dce35a096af1fb7d2}
A utility function to swap data. 